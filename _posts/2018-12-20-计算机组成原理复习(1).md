---
layout:     post
title:      计算机组成原理复习笔记-1
subtitle:   学习
date:       2018-12-15
author:     XHT
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 计算机组成原理
---

## 十进制到二进制的转换


> 整数部分的转换

十进制整数转换为二进制整数采用"除2取余，逆序排列"法。具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

![](https://www.runoob.com/wp-content/uploads/2018/11/210-2.png)

> 小数部分的转换

十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。

然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。

![](https://www.runoob.com/wp-content/uploads/2018/11/210-3.png)

## 原码,反码,补码

一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器码。

> 原码


原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值
```
[+1]原 = 0000 0001

[-1]原 = 1000 0001

         x                           2^n>=x>=0
[x]原=
         2^n-x = 2^n +|x|            0>=x>=-2^n

```
> 反码

反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

ps:取反即1变0,0变1
```
[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反
```

> 补码

补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

```
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

         x                           2^n>=x>=0
[x]原=
         2^(n+1)+x = 2^(n+1) -|x|    0>=x>=-2^n

```

补码有什么用呢?

在计算机计算里,为了方便运算，我们将减法变为加法。这样子只需要一个加法器即可以完成运算

用一个钟表来说明补码的概念

当现在是7点,我们想知道4个小时前是几点的时候,我们有两种等价的方法

7-3=4 (mod 12)

7+9=4 (mod 12)

**所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!**

我们运用了溢出将减法改成了加法

## 补码的运用

对于一个正数来说,他的补码就是他本身。而对于负数来说，他的补码就是他的上限-他本身的绝对值。如上面的公式所表示。（在钟表的例子里，这个上限就是12）

采用补码表示法进行减法运算比原码方便，因为不论数是正或负，机器总是做加法，减法运算可以变成加法运算。

> 补码与真值的关系

![](https://img-blog.csdn.net/20180325175725877?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTY1NjU3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

所以知道一个数的补码,我们就可以很清楚他的真值

> 补码的加法

**[x]补+[y]补=[x+y]补  mod(2^(n+1))   **

ps:其实就是mod他的上限值

***例题***
```
[x]补=01001,[y]补=00101,求x+y

        [x]补 01001
    +   [y]补 00101
    ————————————————————
    [x+y]补   01110
```


```
[x]补=01011,[y]补=11011,求x+y

        [x]补 01011
    +   [y]补 11011
    ————————————————————
    [x+y]补  100110

```
这里用了溢出代替减法

已知补码我们就可以求出对应的真值了

> 补码的减法

**[x]补-[y]补=[x-y]补=[x]补+[-y]补   **

**[-y]补=(~[y]补)+2^(-n)**

ps:+2^(-n) 是在最低位上+1,~为取反操作，具体看反码


## 原码并行乘法

乘积符号的运算法则为异或运算

数值部分的运算方法与普通的十进制乘法相类似


```
[x]原=01111,[y]原=11101

符号位单独考虑
结果符号为  0^1=1


数值部分进行运算


             1111
X            1101
——————————————————————
             1111
            0000
           1111
+         1111
——————————————————————————
         11000011


验证:
 -(11000011)2=(-195)10

 (10)10*(-13)10=(-195)10
 计算正确

```
