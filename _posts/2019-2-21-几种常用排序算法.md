---
layout:     post
title:      几种常用排序算法
subtitle:   简单易懂
date:       2019-02-15
author:     BY
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 算法
---

### 冒泡排序

这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。（来自百度百科）

**算法过程**

从待排序序列的起始位置开始，依次比较各个位置和其后一位置的大小如果当前位置的值大于其后一位置的值，就把他俩的值交换。在一次从头到尾的完整交换后，最大的元素已经通过冒泡升到了最后的位置，在第二次冒泡过程中，那么我们就不用考虑元素跟最后位置的比较了。重复以上过程，直到将所有最大元素都已经冒泡完成。 

``` c++
int arr[10]={2,5,6,8,10,34,1,3,20,4};

for(int i=0;i<10;i++)
{
  for(int j=0;j<10-i-1;j++)
  {
    if(a[i]>a[j]) swap(a[i],a[j]);
  }
}
```

### 插入排序

有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。
插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。（百度百科）

很简单的思路，如果是数组类的添加就比较麻烦，如果是链表的话就方便多了，查找可以是O（n），也有二分查找O（logn）。


### 归并排序

归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。（百度百科）
**过程**
S1如果序列长度大于等于2就将一个序列排序问题变成2个子序列排序问题，如果序列长度为1，则以临时空间对上层序列询问返回该序列
S2对这两个子序列进行S1操作

**对返回子序列的处理**

对返回的子序列如何进行处理呢？

从最底层，最小的子问题返回的子序列的长度都为1。假设我们有两个最小子序列(由数组表示)a={1},b={3}。它们由另一个子序列分化而来，通过返回的序列结果，我们进行序列合并，得到一个递增的序列c{null,null},因为a[0]<b[0]，所以a[0]先进入数组,此时c{1,null}，a序列为空，则继续，完成后c{1,3};

由于我们是底向上进行序列归并，只要严格按照规定进行序列合并，那我们产生的序列都是递增（符合自己定义）的。


![](https://img-blog.csdn.net/20180530173456808?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tfa29yaXM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
![](https://img-blog.csdn.net/20180530173953848?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tfa29yaXM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

``` c++
void merge(int a[],int l,int r,int mid)
{
  int aux[r-l+1],i,j,k;

  for(k=l;k<=r;k++)
  aux[k-l]=a[k];

  i=l;
  j=mid+1;
  for(k=l;k<=r;k++)
  {
  	if(i>mid)
  	{
  		a[k]=aux[j-l];
  		j++;
	  }
	else if(j>r)
	{
		a[k]=aux[i-l];
		i++;
	  }
	else if(aux[i-l]>aux[j-l])
	{
		a[k]=aux[j-l];
		j++;
		}
	else
	{
		a[k]=aux[i-l];
		i++;
			}


	  }

}

void merge_sort(int a[],int l,int r)
{
    if(l>=r)
	return ;

	int mid=(l+r)/2;

	merge_sort(a,l,mid);
	merge_sort(a,mid+1,r);
	merge(a,l,r,mid);

}


void mergesort(int a[],int l,int r)
{
	merge_sort(a,l,r-1);
}

```


### 直接选择排序

一种简单的排序思想。
第一次从R[0]~R[n-1]中选取最小值，与R[0]交换， 
第二次从R[1]~R[n-1]中选取最小值，与R[1]交换， 
….， 
第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换， 
…..， 
第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换， 
共通过n-1次，得到一个从小到大排列的有序序列。


```c++
int arr[10]={2,5,6,8,10,34,1,3,20,4};

for(int i=0;i<10;i++)
{
  int pos=i;
  for(int j=i;j<10;j++)
  {
    if(a[j]<a[pos]) pos=j;
  }
  swap(a[pos],a[i]);
}
```

### 快速排序

随机选取一个数组区间里的一个值，作为评判标准，比这个值小的都放这个值位置的左边，比这个值大的都放这个值位置的右边，将这段子区间继续进行递归操作，类似归并排序，不过将序列有序化是由往下拆分为子问题的时候解决的。

**网上找的参考图片**
![](http://bbs.ahalei.com/data/attachment/forum/201402/25/232129ogop8gk0r8y7l70k.png)
